<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>2048 with Image for 2</title>
<style>
  :root {
    --board-size: 500px;
    --bg: #faf8ef;
    --board-bg: #bbada0;
    --tile-gap: 12px;
    --tile-radius: 8px;
    --font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family:var(--font-family);}
  .wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:24px;}
  .game {
    width:var(--board-size);
    max-width:96vw;
  }
  header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
  h1{margin:0;font-size:20px;color:#776e65}
  .controls{display:flex;gap:8px}
  button{padding:6px 10px;border-radius:6px;border:none;background:#8f7a66;color:white;cursor:pointer}
  .board {
    background:var(--board-bg);
    padding:var(--tile-gap);
    border-radius:12px;
    position:relative;
    box-sizing:border-box;
  }
  canvas{width:100%;height:auto;display:block;border-radius:8px}
  .info{margin-top:10px;color:#776e65;font-size:14px}
</style>
</head>
<body>
  <div class="wrap">
    <div class="game">
      <header>
        <h1>2048 (圖片：EDUperience_logo.png -> 數字 2)</h1>
        <div class="controls">
          <button id="btnNew">New Game</button>
          <button id="btnUndo">Undo</button>
        </div>
      </header>

      <div class="board">
        <canvas id="c"></canvas>
      </div>

      <div class="info">
        方向鍵或 WASD 控制。若圖片未載入會回退顯示純色方塊與數字。
      </div>
    </div>
  </div>

<script>
/*
  簡化的 2048 實作（核心邏輯＋繪製）
  要點：
  - 使用 EDUperience_logo.png（與此 HTML 同一資料夾）當作數字 2 的 tile graphic。
  - cover 模式：圖片以填滿方塊方式畫入（保持比例，超出部分裁切）。
*/

const SIZE = 4;
const GAP = 12;
const TILE_RADIUS = 8;
const BOARD_PX = 500; // base pixel for canvas drawing (會依 CSS 寬度縮放)
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let board = [];
let score = 0;
let prevState = null;

// 圖片資源
const imgMap = {};
const assets = { 2: 'EDUperience_logo.png' }; // 圖片檔名（與 HTML 同一資料夾）

// 初始化 canvas 大小，處理 HiDPI
function resizeCanvas() {
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.round(rect.width * dpr);
  canvas.height = Math.round(rect.width * dpr); // 正方形
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  render();
}

// 預載圖片（同資料夾，省略 crossOrigin）
function loadImages(map) {
  const ps = [];
  for (const k in map) {
    const url = map[k];
    const img = new Image();
    const p = new Promise((res) => {
      img.onload = () => { imgMap[k] = img; res(); };
      img.onerror = () => { console.warn('Image failed:', url); imgMap[k] = null; res(); };
    });
    img.src = url;
    ps.push(p);
  }
  return Promise.all(ps);
}

// 初始化 board
function initBoard() {
  board = Array.from({length:SIZE},()=>Array(SIZE).fill(0));
  score = 0;
  prevState = null;
  placeRandom();
  placeRandom();
  render();
}

// 放置隨機方塊（2 或 4）
function placeRandom() {
  const empties = [];
  for (let y=0;y<SIZE;y++) for (let x=0;x<SIZE;x++) if (board[y][x]===0) empties.push({x,y});
  if (!empties.length) return;
  const spot = empties[Math.floor(Math.random()*empties.length)];
  const v = Math.random() < 0.9 ? 2 : 4;
  board[spot.y][spot.x] = v;
}

// 簡單狀態複製（用於 undo）
function cloneState() {
  return { board: board.map(r=>r.slice()), score };
}
function restoreState(s) {
  if (!s) return;
  board = s.board.map(r=>r.slice());
  score = s.score;
  render();
}

// 移動邏輯（上/下/左/右）
function move(dir) {
  // dir: 'left','right','up','down'
  prevState = cloneState();
  let moved = false;
  const mergedFlag = Array.from({length:SIZE},()=>Array(SIZE).fill(false));

  const iter = (x,y) => ({x,y});
  const range = (a,b,step=1) => { const arr=[]; for(let i=a;i!==b;i+=step) arr.push(i); return arr; };

  const traverse = {
    left:  { xs: range(0,SIZE,1), ys: range(0,SIZE,1),  dx:-1, dy:0,  primary:'x'},
    right: { xs: range(SIZE-1,-1,-1), ys: range(0,SIZE,1), dx:1, dy:0, primary:'x' },
    up:    { xs: range(0,SIZE,1), ys: range(0,SIZE,1), dx:0, dy:-1, primary:'y' },
    down:  { xs: range(0,SIZE,1), ys: range(SIZE-1,-1,-1), dx:0, dy:1, primary:'y' }
  }[dir];

  const movedThis = () => moved;

  if (!traverse) return;

  // generic move by repeatedly sliding each tile toward direction
  const trySlide = (sx, sy, dx, dy) => {
    if (board[sy][sx]===0) return false;
    let x = sx, y = sy;
    while (true) {
      const nx = x + dx, ny = y + dy;
      if (nx<0||nx>=SIZE||ny<0||ny>=SIZE) break;
      if (board[ny][nx] === 0) {
        board[ny][nx] = board[y][x];
        board[y][x] = 0;
        x = nx; y = ny;
        moved = true;
        continue;
      } else if (board[ny][nx] === board[y][x] && !mergedFlag[ny][nx] && !mergedFlag[y][x]) {
        board[ny][nx] *= 2;
        board[y][x] = 0;
        mergedFlag[ny][nx] = true;
        score += board[ny][nx];
        moved = true;
        break;
      } else break;
    }
    return true;
  };

  // run sweep multiple times to ensure full slide
  for (let pass=0; pass<SIZE; pass++) {
    for (const y of traverse.ys) {
      for (const x of traverse.xs) {
        trySlide(x,y,traverse.dx,traverse.dy);
      }
    }
  }

  if (moved) placeRandom();
  render();
  return moved;
}

// 判斷是否可移動（簡單）
function canMove() {
  for (let y=0;y<SIZE;y++) for (let x=0;x<SIZE;x++) {
    if (board[y][x]===0) return true;
    const v = board[y][x];
    if (x+1<SIZE && board[y][x+1]===v) return true;
    if (y+1<SIZE && board[y+1][x]===v) return true;
  }
  return false;
}

// 繪製
function render() {
  // canvas 寬度為 CSS 寬度（正方形），取得實際像素大小在 resizeCanvas 已處理
  const rect = canvas.getBoundingClientRect();
  const W = rect.width;
  // 背景清空
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // 計算 tile 大小（cover board area）
  const gap = GAP;
  const totalGap = gap * (SIZE + 1);
  const tileSize = (W - totalGap) / SIZE;
  // 畫整個背景區塊（圓角）
  const boardW = W;
  const boardH = W;
  // 背景矩形（已在 CSS 有，但為了 canvas 美觀再畫一次淺背景）
  ctx.fillStyle = '#bbada0';
  roundRect(ctx, 0, 0, boardW, boardH, 12, true, false);

  // draw empty slots
  ctx.fillStyle = '#cdc1b4';
  for (let y=0;y<SIZE;y++){
    for (let x=0;x<SIZE;x++){
      const px = gap + x*(tileSize+gap);
      const py = gap + y*(tileSize+gap);
      roundRect(ctx, px, py, tileSize, tileSize, TILE_RADIUS, true, false);
    }
  }

  // draw tiles
  for (let y=0;y<SIZE;y++){
    for (let x=0;x<SIZE;x++){
      const val = board[y][x];
      if (val===0) continue;
      const px = gap + x*(tileSize+gap);
      const py = gap + y*(tileSize+gap);

      // tile bg
      const bg = tileBackgroundColor(val);
      ctx.fillStyle = bg;
      roundRect(ctx, px, py, tileSize, tileSize, TILE_RADIUS, true, false);

      // if val === 2 and image loaded -> draw image in cover mode
      if (val === 2 && imgMap[2]) {
        drawImageCover(ctx, imgMap[2], px, py, tileSize, tileSize);
      } else {
        // draw number text
        ctx.fillStyle = tileTextColor(val);
        const fontSize = Math.floor(tileSize * (val >= 1024 ? 0.36 : 0.5));
        ctx.font = `bold ${fontSize}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(String(val), px + tileSize/2, py + tileSize/2);
      }
    }
  }
}

// 輔助：cover 模式畫圖（保持比例，填滿並裁切）
function drawImageCover(ctx, img, x, y, w, h) {
  const imgRatio = img.width / img.height;
  const boxRatio = w / h;
  let sx, sy, sw, sh;
  if (imgRatio > boxRatio) {
    // 圖片較寬 -> 剪掉左右
    sh = img.height;
    sw = img.height * boxRatio;
    sx = (img.width - sw) / 2;
    sy = 0;
  } else {
    // 圖片較高 -> 剪掉上下
    sw = img.width;
    sh = img.width / boxRatio;
    sx = 0;
    sy = (img.height - sh) / 2;
  }
  ctx.save();
  // create inner padding so image doesn't touch rounded corners too tightly
  const pad = Math.max(4, Math.floor(w * 0.06));
  const dx = x + pad, dy = y + pad, dw = w - pad*2, dh = h - pad*2;
  // clip to rounded rect
  clipRoundRect(ctx, dx, dy, dw, dh, TILE_RADIUS);
  ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);
  ctx.restore();
}

// 顏色設定（簡單版）
function tileBackgroundColor(val) {
  const map = {
    2: '#eee4da',
    4: '#ede0c8',
    8: '#f2b179',
    16: '#f59563',
    32: '#f67c5f',
    64: '#f65e3b',
    128: '#edcf72',
    256: '#edcc61',
    512: '#edc850',
    1024: '#edc53f',
    2048: '#edc22e'
  };
  return map[val] || '#3c3a32';
}
function tileTextColor(val) {
  return val <= 4 ? '#776e65' : '#f9f6f2';
}

// 圓角矩形與剪裁
function roundRect(ctx,x,y,w,h,r,fill,stroke){
  if (r> w/2) r = w/2;
  if (r> h/2) r = h/2;
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}
function clipRoundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
  ctx.clip();
}

// 鍵盤控制
window.addEventListener('keydown', (e)=>{
  if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','w','a','s','d','W','A','S','D'].includes(e.key)) {
    e.preventDefault();
    if (e.key === 'ArrowLeft' || e.key==='a' || e.key==='A') move('left');
    if (e.key === 'ArrowRight' || e.key==='d' || e.key==='D') move('right');
    if (e.key === 'ArrowUp' || e.key==='w' || e.key==='W') move('up');
    if (e.key === 'ArrowDown' || e.key==='s' || e.key==='S') move('down');
  }
});

// UI 按鈕
document.getElementById('btnNew').addEventListener('click', initBoard);
document.getElementById('btnUndo').addEventListener('click', ()=>restoreState(prevState));

// 窗口調整
window.addEventListener('resize', resizeCanvas);

// 初始執行
(async function start(){
  // 設定 canvas CSS 大小（正方形），以容器寬度為依據
  const gameEl = document.querySelector('.game');
  const w = Math.min(500, window.innerWidth * 0.9);
  canvas.style.width = w + 'px';
  canvas.style.height = w + 'px';

  await loadImages(assets); // 載入圖片（如果失敗會回退）
  initBoard();
  resizeCanvas();
})();

</script>
</body>
</html>
