<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2048 - HTML5 Canvas 範例</title>
  <style>
    :root{
      --bg:#faf8ef;
      --board:#bbada0;
      --tile-2:#eee4da;
      --tile-4:#ede0c8;
      --tile-text:#776e65;
      --tile-light:#f9f6f2;
      --accent:#f65e3b;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: "Segoe UI", Roboto, "Noto Sans TC", "Helvetica Neue", Arial;
      background:var(--bg);
      color:#333;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:100vh;
      padding:20px;
    }
    .container{
      width:100%;
      max-width:420px;
    }
    header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:12px;
    }
    h1{font-size:22px;margin:0}
    .controls{
      text-align:right;
    }
    button{
      background:#8f7a66;color:#fff;border:0;padding:8px 12px;border-radius:6px;
      font-weight:600;cursor:pointer;
    }
    .scoreboard{
      display:flex;
      gap:8px;
      align-items:center;
      margin-bottom:8px;
    }
    .score-box{
      background:#eee; padding:8px 12px;border-radius:6px;font-weight:700;
    }
    .info{font-size:13px;color:#666;margin-bottom:8px}
    canvas{
      display:block;
      width:100%;
      height:auto;
      border-radius:10px;
      background:var(--board);
      touch-action: none; /* 禁止預設觸控滾動，讓滑動手勢工作 */
    }
    .footer{font-size:12px;color:#777;margin-top:12px;text-align:center}
    .small{font-size:12px;color:#555}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>2048</h1>
      <div class="controls">
        <button id="restartBtn">重新開始</button>
      </div>
    </header>

    <div class="scoreboard">
      <div class="score-box">分數: <span id="score">0</span></div>
      <div class="score-box">最高: <span id="best">0</span></div>
    </div>

    <div class="info small">使用 ← ↑ → ↓ 或 滑動 來移動方塊。目標合成 2048。</div>

    <canvas id="board" width="500" height="500" aria-label="2048 遊戲畫布"></canvas>

    <div class="footer">示範：純 HTML/CSS/JS（Canvas）實作</div>
  </div>

<script>
/*
  2048 Canvas 範例
  - 支援鍵盤與觸控滑動
  - 支援撤銷一步
  - 使用 localStorage 保存 best score
*/

(() => {
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  const restartBtn = document.getElementById('restartBtn');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');

  // 設定
  const SIZE = 4;                 // 4x4
  let GRID_PX = 500;              // canvas 寬高（像素） — 會依 CSS 伸縮但內部繪圖以此為基準
  const PADDING = 16;
  const TILE_GAP = 12;
  const TILE_RADIUS = 8;
  const TILE_BG = '#cdc1b4';
  const TILE_COLORS = {
    2: {bg:'#eee4da', color:'#776e65'},
    4: {bg:'#ede0c8', color:'#776e65'},
    8: {bg:'#f2b179', color:'#f9f6f2'},
    16: {bg:'#f59563', color:'#f9f6f2'},
    32: {bg:'#f67c5f', color:'#f9f6f2'},
    64: {bg:'#f65e3b', color:'#f9f6f2'},
    128: {bg:'#edcf72', color:'#f9f6f2'},
    256: {bg:'#edcc61', color:'#f9f6f2'},
    512: {bg:'#edc850', color:'#f9f6f2'},
    1024: {bg:'#edc53f', color:'#f9f6f2'},
    2048: {bg:'#edc22e', color:'#f9f6f2'},
  };

  // 遊戲狀態
  let grid = [];
  let score = 0;
  let best = Number(localStorage.getItem('2048_best') || '0');
  let gameOver = false;
  let movedSinceLastUndo = false;
  let prevState = null; // 儲存上一步以支援撤銷（undo）
  bestEl.textContent = best;

  // 調整 canvas 實際繪圖大小以支援高 DPI
  function adjustCanvas() {
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    GRID_PX = Math.floor(Math.min(rect.width, rect.height) * dpr);
    canvas.width = GRID_PX;
    canvas.height = GRID_PX;
    ctx.setTransform(1,0,0,1,0,0);
  }

  window.addEventListener('resize', () => {
    adjustCanvas();
    render();
  });

  // 初始化
  function init() {
    grid = Array.from({length: SIZE}, () => Array(SIZE).fill(0));
    score = 0;
    gameOver = false;
    prevState = null;
    movedSinceLastUndo = false;
    placeRandom();
    placeRandom();
    scoreEl.textContent = score;
    bestEl.textContent = best;
    adjustCanvas();
    render();
  }

  // 複製狀態（深複製）
  function cloneState() {
    return {
      grid: grid.map(row => row.slice()),
      score: score,
      gameOver: gameOver
    };
  }

  function restoreState(st) {
    if (!st) return;
    grid = st.grid.map(row => row.slice());
    score = st.score;
    gameOver = st.gameOver;
    scoreEl.textContent = score;
    render();
  }

  // 隨機在空位放 2 或 4
  function placeRandom() {
    const empties = [];
    for (let r=0;r<SIZE;r++){
      for (let c=0;c<SIZE;c++){
        if (grid[r][c] === 0) empties.push([r,c]);
      }
    }
    if (empties.length === 0) return false;
    const [r,c] = empties[Math.floor(Math.random() * empties.length)];
    grid[r][c] = Math.random() < 0.9 ? 2 : 4;
    return true;
  }

  // 判斷是否有可移動（遊戲結束）
  function canMove() {
    for (let r=0;r<SIZE;r++){
      for (let c=0;c<SIZE;c++){
        if (grid[r][c] === 0) return true;
        const v = grid[r][c];
        if (r < SIZE-1 && grid[r+1][c] === v) return true;
        if (c < SIZE-1 && grid[r][c+1] === v) return true;
      }
    }
    return false;
  }

  // 移動方向: 'left','right','up','down'
  function move(dir) {
    if (gameOver) return false;
    // 儲存狀態以支援 undo
    prevState = cloneState();

    let moved = false;
    let mergedThisMove = Array.from({length: SIZE}, () => Array(SIZE).fill(false));

    function moveLine(get, set) {
      // get(i) -> value at index i along the line (0..SIZE-1)
      // set(i, val) -> set value
      let target = 0; // next position to place
      for (let i=0;i<SIZE;i++){
        let val = get(i);
        if (val === 0) continue;
        // try to merge with previous placed tile if same and not already merged
        let placedVal = get(target);
        if (placedVal === 0) {
          if (target !== i) {
            set(target, val);
            set(i, 0);
            moved = true;
          }
        } else if (placedVal === val && !mergedThisMove_line[target]) {
          // merge into target
          set(target, placedVal*2);
          set(i,0);
          mergedThisMove_line[target] = true;
          score += placedVal*2;
          moved = true;
        } else {
          // advance target
          target++;
          if (target !== i) {
            set(target, val);
            set(i,0);
            moved = true;
          }
        }
      }
    }

    // We'll implement for each direction using closures mapping indexes
    if (dir === 'left' || dir === 'right') {
      for (let r=0;r<SIZE;r++){
        // reset merged tracker per row
        let mergedThisMove_row = Array(SIZE).fill(false);
        // We'll use helper arrays to allow merged flag check
        // But due to structure above, simpler to process left and right separately
        if (dir === 'left') {
          let write = 0;
          for (let c=0;c<SIZE;c++){
            let val = grid[r][c];
            if (val === 0) continue;
            // if can merge with last placed
            if (write>0 && grid[r][write-1] === val && !mergedThisMove_row[write-1]) {
              grid[r][write-1] *= 2;
              score += grid[r][write-1];
              mergedThisMove_row[write-1] = true;
              if (c !== write-1) { grid[r][c] = 0; moved = true; }
            } else {
              if (c !== write) {
                grid[r][write] = val;
                grid[r][c] = 0;
                moved = true;
              }
              write++;
            }
          }
        } else { // right
          let write = SIZE-1;
          for (let c=SIZE-1;c>=0;c--){
            let val = grid[r][c];
            if (val === 0) continue;
            if (write < SIZE-1 && grid[r][write+1] === val && !mergedThisMove_row[write+1]) {
              grid[r][write+1] *= 2;
              score += grid[r][write+1];
              mergedThisMove_row[write+1] = true;
              if (c !== write+1) { grid[r][c] = 0; moved = true; }
            } else {
              if (c !== write) {
                grid[r][write] = val;
                grid[r][c] = 0;
                moved = true;
              }
              write--;
            }
          }
        }
      }
    } else { // up or down
      for (let c=0;c<SIZE;c++){
        let mergedThisMove_col = Array(SIZE).fill(false);
        if (dir === 'up') {
          let write = 0;
          for (let r=0;r<SIZE;r++){
            let val = grid[r][c];
            if (val === 0) continue;
            if (write>0 && grid[write-1][c] === val && !mergedThisMove_col[write-1]) {
              grid[write-1][c] *= 2;
              score += grid[write-1][c];
              mergedThisMove_col[write-1] = true;
              if (r !== write-1) { grid[r][c] = 0; moved = true; }
            } else {
              if (r !== write) {
                grid[write][c] = val;
                grid[r][c] = 0;
                moved = true;
              }
              write++;
            }
          }
        } else { // down
          let write = SIZE-1;
          for (let r=SIZE-1;r>=0;r--){
            let val = grid[r][c];
            if (val === 0) continue;
            if (write < SIZE-1 && grid[write+1][c] === val && !mergedThisMove_col[write+1]) {
              grid[write+1][c] *= 2;
              score += grid[write+1][c];
              mergedThisMove_col[write+1] = true;
              if (r !== write+1) { grid[r][c] = 0; moved = true; }
            } else {
              if (r !== write) {
                grid[write][c] = val;
                grid[r][c] = 0;
                moved = true;
              }
              write--;
            }
          }
        }
      }
    }

    if (moved) {
      movedSinceLastUndo = true;
      placeRandom();
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        localStorage.setItem('2048_best', String(best));
        bestEl.textContent = best;
      }
      if (!canMove()) {
        gameOver = true;
      }
      render();
    } else {
      // 若沒移動，撤回 prevState（避免覆蓋）
      prevState = null;
    }
    return moved;
  }

  // 簡單撤銷一步
  function undo() {
    if (!prevState) return;
    restoreState(prevState);
    prevState = null;
    movedSinceLastUndo = false;
  }

  // 繪製圓角矩形
  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  // 渲染格子
  function render() {
    const W = canvas.width;
    const H = canvas.height;
    ctx.clearRect(0,0,W,H);

    const boardPadding = Math.floor(W * 0.032);
    const gap = Math.floor(W * 0.024);
    const tileSize = Math.floor((W - boardPadding*2 - gap*(SIZE-1)) / SIZE);

    // 背景
    ctx.fillStyle = '#bbada0';
    roundRect(boardPadding, boardPadding, W - boardPadding*2, W - boardPadding*2, 12);
    ctx.fill();

    // 空格子背景
    for (let r=0;r<SIZE;r++){
      for (let c=0;c<SIZE;c++){
        const x = boardPadding + c*(tileSize+gap);
        const y = boardPadding + r*(tileSize+gap);
        ctx.fillStyle = TILE_BG;
        roundRect(x,y,tileSize,tileSize,8);
        ctx.fill();
      }
    }

    // Tiles
    for (let r=0;r<SIZE;r++){
      for (let c=0;c<SIZE;c++){
        const val = grid[r][c];
        if (val === 0) continue;
        const x = boardPadding + c*(tileSize+gap);
        const y = boardPadding + r*(tileSize+gap);
        const style = TILE_COLORS[val] || {bg:'#3c3a32', color:'#f9f6f2'};
        ctx.fillStyle = style.bg;
        roundRect(x,y,tileSize,tileSize,8);
        ctx.fill();

        // 文字
        ctx.fillStyle = style.color;
        // 字級依數字長度縮放
        const txt = String(val);
        let fontSize = Math.floor(tileSize * (txt.length >= 4 ? 0.28 : txt.length === 3 ? 0.38 : 0.5));
        ctx.font = `bold ${fontSize}px "Segoe UI", Roboto, Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(txt, x + tileSize/2, y + tileSize/2 + 2);
      }
    }

    // 如果 game over，繪製遮罩
    if (gameOver) {
      ctx.fillStyle = 'rgba(238,228,218,0.6)';
      roundRect(boardPadding, boardPadding, W - boardPadding*2, W - boardPadding*2, 12);
      ctx.fill();

      ctx.fillStyle = '#776e65';
      ctx.font = `bold ${Math.floor(W*0.06)}px "Segoe UI", Roboto, Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('遊戲結束', W/2, W/2 - 10);
      ctx.font = `normal ${Math.floor(W*0.03)}px "Segoe UI", Roboto, Arial`;
      ctx.fillText('按重新開始 或 按 R 鍵', W/2, W/2 + 30);
    }
  }

  // 鍵盤
  window.addEventListener('keydown', (e) => {
    if (e.key === 'r' || e.key === 'R') {
      init();
      return;
    }
    if (gameOver) return;
    let moved = false;
    if (e.key === 'ArrowLeft') moved = move('left');
    else if (e.key === 'ArrowRight') moved = move('right');
    else if (e.key === 'ArrowUp') moved = move('up');
    else if (e.key === 'ArrowDown') moved = move('down');
    else if ((e.ctrlKey || e.metaKey) && (e.key === 'z' || e.key === 'Z')) {
      undo();
    }
    if (moved) e.preventDefault();
  });

  // 觸控滑動支援（手機）
  (function addTouchControls(){
    let startX = 0, startY = 0, endX=0, endY=0, started=false;
    const threshold = 20; // 最小滑動距離（像素）
    canvas.addEventListener('pointerdown', (e) => {
      started = true;
      startX = e.clientX;
      startY = e.clientY;
    });
    window.addEventListener('pointermove', (e) => {
      if (!started) return;
      endX = e.clientX;
      endY = e.clientY;
    });
    window.addEventListener('pointerup', (e) => {
      if (!started) return;
      started = false;
      const dx = endX - startX;
      const dy = endY - startY;
      if (Math.abs(dx) < threshold && Math.abs(dy) < threshold) return;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 0) move('right'); else move('left');
      } else {
        if (dy > 0) move('down'); else move('up');
      }
    });
    // 防止手指在 canvas 上滾動導致頁面移動
    canvas.addEventListener('touchmove', (e) => e.preventDefault(), {passive:false});
  })();

  // 按鈕
  restartBtn.addEventListener('click', init);

  // 初始化並繪製
  init();

  // 提示：你可以在外層控制台使用 move('left') 等函式來手動移動，或使用 undo() 撤銷。
  window._game2048 = {
    move, undo, getState: () => ({grid: grid.map(r=>r.slice()), score, best, gameOver})
  };
})();
</script>
</body>
</html>
